---

- hosts: main
  remote_user: root
  vars_files:
    - ../vars/default.yml
    - ../vars/credentials.yml

  tasks:

    - set_fact:
        app_name: app
        domain_main: dev.mif.io

    - set_fact:
        root_dir: "{{root_apps_dir}}/{{app_name}}"

    - name: Create directory
      file: "path={{root_dir}}/code state=directory"

    - name: Create directory
      file: "path={{root_dir}}/acme state=directory"

    - name: Sync app code
      synchronize:
        src: ../../server/
        dest: "{{root_dir}}/code/"
        # rsync_opts:
        #   - exclude='node_modules'

    - name: Run docker-compose
      docker_service:
        state: present
        recreate: always
        project_name: "{{app_name}}"
        scale:
          node: 3
        definition:
          version: '2'
          services:
            # `node` key will be used for nginx upstream list
            # `node.iteritems()`
            node:
              build: "{{root_dir}}/code"
              restart: always

          # this stuff garantee that balancer container will have
          # access to the current containers
          networks:
            default:
              external:
                name: balancer_network

    # var 'node' is available down
    # TODO: wait server run

    # zero downtime deploy
    # states:
    # up new containers
    # update upstream
    # reload
    # waiting old containers stop serve
    # stop old containers
    #
    # rename containers with old prefix
    # update upstream


    - name: Gen nginx upstream files
      copy:
        dest: "{{conf_balancer_dir}}/{{app_name}}.upstream"
        content: |
          upstream {{app_name}} {
            # autogenerated from docker_service result
            {% for conteiner_name, value in node.iteritems() %}
            server {{conteiner_name}}:3000 ;
            {% endfor %}
          }

    - name: Gen nginx conf file (with acme .well-known)
      copy:
        dest: "{{conf_balancer_dir}}/{{app_name}}.conf"
        content: |
          server {
            listen       80;
            server_name  {{domain_main}};
            # access_log   logs/domain2.access.log  main;

            # serve static files
            # location ~ ^/(images|javascript|js|css|flash|media|static)/  {
            #   root    /var/www/virtual/big.server.com/htdocs;
            #   expires 30d;
            # }
            location ~ /.well-known {
                # allow all;
                # try_files $uri $uri/index.html;
                root {{in_container_acme_dir}};
                autoindex on;
            }
            location / {
              # see {{app_name}}.upstream.conf file
              proxy_pass      http://{{app_name}};
            }
          }


    - name: Reload balancer
      command: docker exec balancer nginx -s reload

    # TODO: waiting for ssl  certs exists
    - name: Create request-domains.txt
      copy:
        dest: "{{root_dir}}/acme/request-domains.txt"
        content: |
            {{domain_main}}

    - name: Ask letsencrypt
      command: docker restart letsencrypt

    - name: Await cert file (on host machine not container)
      wait_for:
        path: "{{root_balancer_dir}}/letsencrypt/live/{{domain_main}}/fullchain.pem"

    - name: Gen nginx SSL conf file
      copy:
        dest: "{{conf_balancer_dir}}/{{app_name}}.ssl.conf"
        content: |
          server {

            listen 443 ssl http2 default_server;
            listen [::]:443 ssl http2 default_server;
            server_name {{domain_main}};

            ssl_certificate /etc/letsencrypt/live/{{domain_main}}/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/{{domain_main}}/privkey.pem;

            # TODO: move to
            #include snippets/ssl-params.conf;

            # from https://cipherli.st/
            # and https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html

            ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
            ssl_prefer_server_ciphers on;
            ssl_ciphers "EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH";
            ssl_ecdh_curve secp384r1;
            ssl_session_cache shared:SSL:10m;
            ssl_session_tickets off;
            ssl_stapling on;
            ssl_stapling_verify on;
            resolver 8.8.8.8 8.8.4.4 valid=300s;
            resolver_timeout 5s;
            # Disable preloading HSTS for now.  You can use the commented out header line that includes
            # the "preload" directive if you understand the implications.
            #add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";

            # TODO: implement `openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048`
            # add_header Strict-Transport-Security "max-age=63072000; includeSubdomains";
            # add_header X-Frame-Options DENY;
            # add_header X-Content-Type-Options nosniff;
            #
            # ssl_dhparam /etc/ssl/certs/dhparam.pem;

            location / {
                proxy_pass      http://{{app_name}};
            }
          }

    - name: Reload balancer
      command: docker exec balancer nginx -s reload


    # TODO: waiting for url
