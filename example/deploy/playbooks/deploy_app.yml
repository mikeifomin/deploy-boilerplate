---

- hosts: main
  remote_user: root
  vars_files:
    - ../vars/default.yml
    - ../vars/credentials.yml

  tasks:

    # TODO: add list of domains
    - set_fact:
        app_name: app
        domain_main: dev.mif.io

    - set_fact:
        root_dir: "{{root_apps_dir}}/{{app_name}}"

    - name: Create directory for an application code
      file: "path={{root_dir}}/code state=directory"

    - name: Create directory for SSL cert hook (.well-known/acme-challenge)
      file: "path={{root_dir}}/acme state=directory"

    - name: Sync app code
      synchronize:
        src: ../../server/
        dest: "{{root_dir}}/code/"
        # rsync_opts:
        #   - exclude='node_modules'

    - name: Run docker-compose
      docker_service:
        state: present
        recreate: always
        project_name: "{{app_name}}"
        scale:
          node: 3
        definition:
          version: '2'
          services:
            # `node` key will be used for nginx upstream list
            # `node.iteritems()`
            node:
              build: "{{root_dir}}/code"
              restart: always

          # this stuff guarantee that the balancer container will have
          # access to current containers
          networks:
            default:
              external:
                name: balancer_network

    - name: Gen nginx upstream files
      copy:
        dest: "{{conf_balancer_dir}}/{{app_name}}.upstream"
        content: |
          # autogenerated by docker_service
          upstream {{app_name}} {
            {% for conteiner_name, value in node.iteritems() %}
              server {{conteiner_name}}:3000 ;
            {% endfor %}
          }

    # TODO: backup conf file. or create new and if changed backup old one
    - name: Gen nginx conf file (with acme .well-known)
      copy:
        dest: "{{conf_balancer_dir}}/{{app_name}}.conf"
        content: |
          server {
            listen       80;
            server_name  {{domain_main}};
            # access_log   logs/domain2.access.log  main;

            # serve static files
            # location ~ ^/(images|javascript|js|css|flash|media|static)/  {
            #   root    /var/www/virtual/big.server.com/htdocs;
            #   expires 30d;
            # }

            # this import for SSL letsencrypt
            location ~ /.well-known {
                root {{in_container_acme_dir}};
            }
            location / {
              # see {{app_name}}.upstream file
              proxy_pass      http://{{app_name}};
            }
          }

    - name: Reload balancer for make available http://<host>:80/.well-known/...
      command: docker exec balancer nginx -s reload

    # TODO: check availabilty /.well-known
    # if bad remove or rename conf file. for example <app_name>.conf.error

    - name: Create request-domains.txt - file with domains should be created
      copy:
        dest: "{{root_dir}}/acme/request-domains.txt"
        content: |
            {{domain_main}}

    - name: Ask letsencrypt
      command: docker restart letsencrypt

    - name: Await cert file (on host machine not container)
      wait_for:
        path: "{{root_balancer_dir}}/letsencrypt/live/{{domain_main}}/fullchain.pem"

    - name: Gen nginx SSL conf file
      copy:
        dest: "{{conf_balancer_dir}}/{{app_name}}.ssl.conf"
        content: |
          server {

            listen 443 ssl http2 default_server;
            listen [::]:443 ssl http2 default_server;
            server_name {{domain_main}};

            ssl_certificate /etc/letsencrypt/live/{{domain_main}}/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/{{domain_main}}/privkey.pem;

            # TODO: move to
            #include snippets/ssl-params.conf;

            # from https://cipherli.st/
            # and https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html

            ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
            ssl_prefer_server_ciphers on;
            ssl_ciphers "EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH";
            ssl_ecdh_curve secp384r1;
            ssl_session_cache shared:SSL:10m;
            ssl_session_tickets off;
            ssl_stapling on;
            ssl_stapling_verify on;
            resolver 8.8.8.8 8.8.4.4 valid=300s;
            resolver_timeout 5s;
            # Disable preloading HSTS for now.  You can use the commented out header line that includes
            # the "preload" directive if you understand the implications.
            #add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";

            # TODO: implement `openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048`
            # add_header Strict-Transport-Security "max-age=63072000; includeSubdomains";
            # add_header X-Frame-Options DENY;
            # add_header X-Content-Type-Options nosniff;
            #
            # ssl_dhparam /etc/ssl/certs/dhparam.pem;

            location / {
                proxy_pass      http://{{app_name}};
            }
          }

    - name: Reload balancer
      command: docker exec balancer nginx -s reload


    # TODO: waiting for url
