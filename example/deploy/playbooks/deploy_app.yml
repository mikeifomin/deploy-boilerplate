---

- hosts: main
  remote_user: root
  vars_files:
    - ../vars/default.yml
    - ../vars/credentials.yml

  tasks:

    - set_fact:
        app_name: app
        domain_main: dev.mif.io

    - set_fact:
        root_dir: "{{root_apps_dir}}/{{app_name}}"

    - name: Create directory
      file: "path={{root_dir}}/code state=directory"

    - name: Sync app code
      synchronize:
        src: ../../server/
        dest: "{{root_dir}}/code/"
        rsync_opts:
          - exclude='node_modules'

    - name: Run docker-compose
      docker_service:
        state: present
        recreate: always
        project_name: "{{app_name}}"
        scale:
          node: 3
        definition:
          version: '2'
          services:
            # `node` key will be used for nginx upstream list
            # `node.iteritems()`
            node:
              build: "{{root_dir}}/code"
              restart: always
              
          # this stuff garantee that balancer container will have
          # access to the current containers
          networks:
            default:
              external:
                name: balancer_network

    # var 'node' is available down
    # TODO: wait server run

    # zero downtime deploy
    # states:
    # up new containers
    # update upstream
    # reload
    # waiting old containers stop serve
    # stop old containers
    #
    # rename containers with old prefix
    # update upstream

    - name: Gen nginx upstream files
      copy:
        dest: "{{conf_balancer_dir}}/{{app_name}}.upstream.conf"
        content: |
          upstream {{app_name}} {
            # autogenerated from docker_service result
            {% for conteiner_name, value in node.iteritems() %}
            server {{conteiner_name}}:3000 ;
            {% endfor %}
          }

    - name: Gen nginx conf file
      copy:
        dest: "{{conf_balancer_dir}}/{{app_name}}.conf"
        content: |

          # server {
          #   listen 443 ssl;
          #   server_name  {{domain_main}};
            # Dynamic handler for issuing or returning certs for SNI domains.
            # ssl_certificate_by_lua_block {
            #   auto_ssl:ssl_certificate()
            # }

            # You must still define a static ssl_certificate file for nginx to start.
            #
            # You may generate a self-signed fallback with:
            #
            # openssl req -new -newkey rsa:2048 -days 3650 -nodes -x509 \
            #   -subj '/CN=sni-support-required-for-valid-ssl' \
            #   -keyout /etc/ssl/resty-auto-ssl-fallback.key \
            #   -out /etc/ssl/resty-auto-ssl-fallback.crt
          #   ssl_certificate /etc/ssl/resty-auto-ssl-fallback.crt;
          #   ssl_certificate_key /etc/ssl/resty-auto-ssl-fallback.key;
          #   location / {
          #     proxy_pass      http://upstream_{{app_name}};
          #   }
          # }
          server {
            listen       80;
            server_name  {{domain_main}};
            # access_log   logs/domain2.access.log  main;

            # serve static files
            # location ~ ^/(images|javascript|js|css|flash|media|static)/  {
            #   root    /var/www/virtual/big.server.com/htdocs;
            #   expires 30d;
            # }

            location / {
              # see {{app_name}}.upstream.conf file
              proxy_pass      http://{{app_name}};
            }
          }

    - name: Reload balancer
      command: docker exec balancer nginx -s reload

    # TODO: waiting for url
